<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abalone27&#39;s Blog</title>
  
  
  <link href="https://abalone27.github.io/atom.xml" rel="self"/>
  
  <link href="https://abalone27.github.io/"/>
  <updated>2024-10-26T05:54:28.531Z</updated>
  <id>https://abalone27.github.io/</id>
  
  <author>
    <name>Yuxiang Bao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OS：处理机调度与死锁🔒</title>
    <link href="https://abalone27.github.io/2024/10/26/chapter%203%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    <id>https://abalone27.github.io/2024/10/26/chapter%203%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/</id>
    <published>2024-10-26T05:43:00.000Z</published>
    <updated>2024-10-26T05:54:28.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理机调度与死锁">处理机调度与死锁🔒</h1><blockquote><p>Q:如果系统只有一个cpu,有两个进程要运行.进程A的运行时间将是1小时,进程B的运行时间是1分钟.那么认为操作系统让哪个进程先运行比较合理?</p></blockquote><p>A：与操作系统的调度策略有关，即更重视优先级还是到来顺序、时长等因素。</p><h2 id="调度">调度</h2><p>对处理机（CPU）资源进行分配。</p><h3 id="调度层次">调度层次</h3><p>高级（作业）调度、中级（内存）调度、低级（进程）调度。</p><p>区分主要是运行频率，<strong>低级调度最频繁</strong>，也是重点。</p><figure><img src="images/diaodu1.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>后备队列</strong>（Spooling Queue 或 BackupQueue）是指操作系统或系统调度过程中用于存放<strong>尚未进入内存执行的进程或任务</strong>的队列。根据实际情况，后备队列可以位于<strong>外存</strong>或与外存相关的区域，而非内存。</p><p>作业（Job）：一组需要完成的任务或程序的组合。</p><ul><li>高级调度：决定哪些后备队列中的（外存中的）作业调入内存并创建进程与分配资源。</li><li>中级调度：决定哪些进程<u>可参与竞争CPU</u>。（内存-&gt;外存）</li><li>低级调度：决定哪个进程可以<u>获得CPU。</u></li></ul><p>低级调度有两种方式：</p><ol type="1"><li>非抢占式：一直执行完成或自动阻塞。</li><li>抢占式：允许其他进程依据一定规则抢占CPU。</li></ol><p>（1）时间片原则、（2）优先权原则 、（3）短作业（进程）优先原则</p><figure><img src="images/diaodu2.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="周转时间-turnaround-time">1. 周转时间 (Turnaround Time)</h2><p>作业（进程）从提交（进入时刻）到完成的时间称为该作业的周转时间(T_i)：</p><p><span class="math display">\[T_i = \text{完成时刻} - \text{进入时刻}\]</span></p><h2 id="平均周转时间-average-turnaround-time">2. 平均周转时间 (AverageTurnaround Time)</h2><p>平均周转时间为 (n) 个作业（进程）周转时间的平均值：</p><p><span class="math display">\[T = \frac{1}{n} \left( \sum_{i=1}^{n} T_i \right)\]</span></p><h2 id="带权周转时间-weighted-turnaround-time">3. 带权周转时间 (WeightedTurnaround Time)</h2><p>作业（进程）周转时间 (T_i) 与实际运行时间 (T_{si})之比称为该作业的带权周转时间 (W_i)：</p><p><span class="math display">\[W_i = \frac{T_i}{T_{si}}\]</span></p><h2 id="平均带权周转时间-average-weighted-turnaround-time">4.平均带权周转时间 (Average Weighted Turnaround Time)</h2><p>平均带权周转时间为 (n) 个作业（进程）带权周转时间的平均值：</p><p><span class="math display">\[W = \frac{1}{n} \left( \sum_{i=1}^{n} \frac{T_i}{T_{si}} \right)\]</span></p><h2 id="调度算法">调度算法</h2><p>根据系统的资源分配策略所规定的资源分配方法</p><ol type="1"><li><h3 id="先来先服务fcfs">先来先服务（FCFS）</h3></li></ol><p>​ 作业调度：从后背队列选择一个或多个最先进入队列的作业</p><ol start="2" type="1"><li><h3 id="短作业进程优先sf">短作业（进程）优先（SF）</h3><p>从就绪队列中选择CPU执行时间最短的作业</p></li><li><h3 id="高响应比优先hrn">高响应比优先（HRN）</h3></li></ol><p>​ 选择待调度的作业中响应比最高的 <span class="math display">\[R_p = \frac{W_i + S_i}{S_i}\]</span> ​ Rp:响应比</p><p>​ Wi：已等待时间</p><p>​ Si：要求服务时间</p><ol start="4" type="1"><li><h3 id="最高优先权hpf">最高优先权（HPF）</h3></li></ol><p>​ 选择优先权最高的，其中又分为：</p><p>​ <strong>静态优先权</strong></p><p>​ <strong>动态优先权</strong></p><ol start="5" type="1"><li><h3 id="时间片轮转rr">时间片轮转（RR）</h3></li></ol><p>​ 每次为一个进程执行一个时间片T</p><ol start="6" type="1"><li><h3 id="多级队列调度">多级队列调度</h3></li></ol><p>​ 将就绪队列分为多种不同队列，不同队列使用不同调度算法</p><p>​ <img src="images/diaodu0.png" alt="img" /></p><ol start="7" type="1"><li><h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3></li></ol><p>​设置多个就绪队列，从高到低赋予不同优先级，每个队列采用RR算法，时间片长度依次增加。</p><h2 id="死锁">死锁</h2><h3 id="概述">概述</h3><p><strong>死锁</strong>是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前进。</p><h3 id="产生原因">产生原因</h3><ol type="1"><li><strong>资源竞争</strong></li></ol><ul><li><p>当两个或以上进程需要两个或以上资源(非剥夺性资源or临时性资源)：</p><ol type="1"><li>可剥夺性资源</li><li>非剥夺性资源</li><li>临时性资源：由某进程产生，由另一进程使用的资源。（信号量）</li></ol></li></ul><ol start="2" type="1"><li><p><strong>进程推进非法</strong></p><p>请求和释放资源的顺序不当。</p></li></ol><h3 id="产生死锁必要条件">产生死锁必要条件</h3><ol type="1"><li><p>互斥条件：请求的资源为<strong>临界资源</strong></p><p><strong>临界资源（CriticalResource）</strong>：指<strong>多个进程或线程在同一时间只能由一个进程使用</strong>的资源。对这种资源的访问必须受到严格的控制，以防止数据<strong>不一致</strong>或<strong>竞争</strong>问题的发生。典型的临界资源包括<strong>共享内存、文件、数据库</strong>等。</p><blockquote><p>可见，访问临界资源必须要有<strong>同步或互斥机制（同步：信号量，互斥：锁）！！</strong></p></blockquote></li><li><p>请求和保持条件：申请新资源，保持旧资源</p></li><li><p>不剥夺条件：已获得的资源，在使用完之前，不被外力剥夺。</p></li><li><p>环路等待条件：互相等待资源</p></li></ol><h3 id="处理死锁的基本方法">处理死锁的基本方法</h3><ol type="1"><li>预防死锁：设置限制条件，破坏死锁产生</li><li>避免死锁：资源分配的动态方法</li><li>检测死锁：采取措施，解除死锁</li><li>解除死锁：剥夺资源或撤销进程回收♻️资源</li></ol><h2 id="银行家算法">银行家算法🏦</h2><h3 id="安全序列">安全序列</h3><p>安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)(称〈P1, P2, …,Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><p>​ • <strong>可用资源</strong>：目前系统中剩余的可用资源数量。</p><p>​ • <strong>最大需求</strong>：每个进程所需的最大资源量。</p><p>​ • <strong>已分配资源</strong>：每个进程当前占用的资源量。</p><p>需求 = <strong>最大需求</strong> - <strong>已分配资源</strong></p><p>要找到一个<strong>安全序列</strong>，需要按照银行家算法，依次寻找一个可以满足当前可用资源条件的进程，完成该进程后，释放其资源，增加可用资源。重复这个过程，直到所有进程都完成。</p><h3 id="算法实现">算法实现</h3><p>核心：根据系统是否处于安全状态，来决定分配资源与否。</p><p>对于银行家算法的具体实现主要由以下几个数据结构：</p><p>1、可利用资源向量Available：</p><p>一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目</p><p>2、最大需求矩阵Max：</p><p>一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求</p><p>3、分配矩阵Allocation：</p><p>一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数</p><p>4、需求矩阵Need：</p><p>一个n×m的矩阵，用以表示每一个进程还需的各类资源数</p><p>Need［i,j］=Max［i,j］-Allocation［i,j］</p><figure><img src="images/bank.png" alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><p>设Requesti是进程Pi的请求向量，如果Requesti［j］=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：</p><ol type="1"><li><p>如果Requesti［j］≤Need［i,j］，便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p></li><li><p>如果Requesti［j］≤Available［j］，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</p></li><li><p>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p></li></ol><p>① Available［j］∶=Available［j］-Requesti［j］;</p><p>② Allocation［i,j］∶=Allocation［i,j］+Requesti［j］;</p><p>③ Need［i,j］∶=Need［i,j］-Requesti［j］;</p><ol start="4" type="1"><li>系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。对于系统整体安全状态的检查，引入安全性算法，核心实现如下：</li></ol><blockquote><ol type="1"><li>设置两个向量：① 工作向量Work:它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work∶=Available;② Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish［i］∶=false;当有足够资源分配给进程时， 再令Finish［i］∶=true。</li><li>从进程集合中找到一个能满足下述条件的进程：  ① Finish［i］=false; ②Need［i,j］≤Work［j］； 若找到， 执行步骤(3)，否则，执行步骤(4)。<br /></li><li>当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：Work［j］∶=Work［i］+Allocation［i,j］; Finish［i］∶=true; go to step2;</li><li>如果所有进程的Finish［i］=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</li></ol></blockquote><p>银行家算法的缺点如下：</p><p>1.很少有进程能够在运行前就知道其所需资源的最大值</p><p>2.而且进程数也不是固定的，往往在不断地变化（如新用户登录或退出）</p><p>3.原本可用的资源也可能突然间变成不可用（如磁带机可能坏掉）</p><p>4.银行家算法的开销较大，实时性不是很好</p><h2 id="解除死锁">解除死锁</h2><p>利用死锁定理</p><figure><img src="images/diaodu3.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>对于死锁的解除，即<strong>（1）剥夺资源，(2) 撤消进程</strong>。</p><p>实用而又简便的方法是：<strong>逐个</strong>撤消那些<strong>代价最小</strong>的进程，或者，使<strong>撤消进程的数量最少</strong>，直至获得为解除死锁所需要的足够可用的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;处理机调度与死锁&quot;&gt;处理机调度与死锁🔒&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Q:如果系统只有一个cpu,有两个进程要运行.进程A的运行时间将是1小时,进程B的运行时间是1分钟.那么认为操作系统让哪个进程先运行比较合理?&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="OS" scheme="https://abalone27.github.io/categories/OS/"/>
    
    
    <category term="操作系统" scheme="https://abalone27.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="死锁" scheme="https://abalone27.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
    <category term="复习" scheme="https://abalone27.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最常见的图像压缩算法：JPEG</title>
    <link href="https://abalone27.github.io/2024/10/22/%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9AJPEG/"/>
    <id>https://abalone27.github.io/2024/10/22/%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9AJPEG/</id>
    <published>2024-10-22T08:22:03.000Z</published>
    <updated>2024-10-26T05:53:49.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dip-jpeg图像压缩">DIP-JPEG图像压缩</h1><h2 id="为什么jpefg有用">为什么JPEFG有用</h2><p>人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。</p><p>因此减少人类眼镜感知较弱的区域，即减少颜色的差异，就可以实现压缩。</p><h2 id="压缩步骤">压缩步骤</h2><ol type="1"><li><p>首先需要进行色彩空间转换，每一个像素都有RGB的红绿蓝叠加，算法需要通过一个固定的公式算出<strong>Y（亮度）、Cb（蓝色色度）、Cr（红色色度）</strong>。</p></li><li><p>进行色度缩减取样，很多数据会被删除。将蓝色和红色色度分量层的像素按照2x2像素成一个区块这样划分。然后计算每个区块的平均值，然后缩小图像（4:2:0），使得含有1个平均值的由4个像素组成的区块只占一个像素的空间。于是那些我们👀眼睛不易感知的红蓝色度信息量shrinkto 1/4size，而亮度（luminance）保持不变。<em>（网上流行的包浆图就是这么来的）</em></p><blockquote><p>考虑一下刚才的两步，计算之前SIZE=1+1+1=3.0，计算之后为SIZE=1+1/4+1/4=1.5，图像已经变为原来大小的一半了。</p></blockquote></li><li><p>当我们查看图像时，会放大图像到原始尺寸，根据YCbCr重新计算RGB<em>（可能发生变化）</em></p></li><li><p>接下来的两个步骤是<strong>重点</strong>，进行<strong>离散余弦变换（DiscreteCosine Transform,DCT）</strong>和<strong>量化（Quantiaztion）</strong>。这利用了人眼不擅长感知高频率的图像信息的原理，即对于细节并不能精确感知。如阴影变化，和摄影中失焦的场景。以上两个步骤会遍历图像各个部分，并找到由高频率色度或亮度的像素频繁出现的区域，然后将这些人眼很难感知的像素删除。对于三个图层中的每一个图层进行以下步骤<em>（以亮度涂层举例）</em>：</p><ul><li>将整个图像<strong>按照8x8像素划分成许多区域</strong>，称为“区块”。每个区块因此有64像素，每个像素用0～255的数值表示。如果是亮度图层就是代表亮度值。</li><li>减去128来改变各个亮度数值，这样取值范围就变成了-128～-127。（亮度图-128为黑色，127为白色）</li><li>每一个区块内，我们可以先找到64个8x8基本图像（正弦函数的频率域图）并且每个图像都会有一个计算得出的DCT系数，原始图像可以通过计算出的每个基本图像✖️它对应的系数后再叠加64次得出。<em>（具体的数学公式笔者也不了解，请自行网上查阅）</em></li></ul><blockquote><p>DCT不能压缩或缩小图像，但下一个步骤，量化可以</p></blockquote></li><li><p>DCT后我们会有一个常数表，我们要把其中的各个值除上对应量化表中的各个值，并四舍五入取整。</p><figure><img src="images/jpeg-0.png" alt="截屏2024-10-22 15.28.33" /><figcaption aria-hidden="true">截屏2024-10-22 15.28.33</figcaption></figure></li></ol><p>​ 量化表右下角数值偏高，是人眼不擅长感知德高频数据。而数值较小的左上角是人眼更容易区分的样式所在。</p><p>​ 在刚才的步骤中，我们舍弃了人眼无法感知的数据，针对色度，我们会采用一个数值更大的量化表，舍去更多的颜色数据。</p><h2 id="小结">小结</h2><ul><li>从本质上讲，整个余弦变换+量化的过程，<strong>一整张图像都使用了一组相同的64个基础图像和两个量化表：一个用于亮度，另一个用于色度。以便将8x8的像素区块转换为几个数字和一大堆的0。</strong></li></ul><h2 id="编码">编码</h2><h3 id="游程编码">游程编码</h3><ul><li><p>在这一步骤中，我们列出所有区块中的亮度与色度数值（更改后）。然而是这样的顺序：</p><figure><img src="images/jpeg-1.png" alt="截屏2024-10-22 15.38.56" /><figcaption aria-hidden="true">截屏2024-10-22 15.38.56</figcaption></figure></li><li><p>因为这样子更可能找到一连串的非0数字。</p></li><li><p>接下来，在我们列出的数字中，使用游程编码Run length encodingalgorithm，列出我们有几个0。这样只有几十个数字的列表显然比0～255的方法压缩的多。</p></li></ul><p><img src="images/jpeg-2.png" style="zoom:50%;" /></p><h3 id="哈夫曼编码-huffman-encoding">哈夫曼编码 Huffman Encoding</h3><p>​这种独立编码也运用在H.264视频压缩算法中（也被称为高级视频编码，AVC），是目前Youtube上传视频推荐的视频压缩算法。它使用了色度所见取样或色度抽样技术，以及离散余弦变换和量化技术的一些变种。</p><p>​ 这里对哈夫曼编码进行简述，感兴趣的可以查阅资料自行了解。</p><ol type="1"><li><p>需要对待编码的数据中每个符号出现的频率进行统计。这些频率将用于构建哈夫曼树。</p></li><li><p>哈夫曼树是一种二叉树，其中每个叶子节点代表一个符号，且路径长度与符号的频率相关。构建哈夫曼树的步骤如下：</p><p>​ 1.<strong>初始化</strong>：将所有符号视为独立的节点，并按照频率从小到大排序。</p><p>​ 2.<strong>合并最小频率的两个节点</strong>：将频率最小的两个节点合并为一个新的父节点，其频率为两个子节点频率之和。</p><p>​ 3.<strong>重复合并</strong>：将新节点加入节点列表中，重新排序，重复步骤2，直到所有节点合并成一棵树。</p></li><li><p>根据哈夫曼树<strong>生成哈夫曼表</strong>，从根节点到每个叶子节点的路径决定了该符号的哈夫曼编码。通常，向左分支记为0，向右分支记为1。</p></li></ol><pre class="mermaid">graph TDRoot[100]Root --> A[45]Root --> CBFED[55]CBFED --> CB[25]CBFED --> FED[30]CB --> C[12]CB --> B[13]FED --> FE[14]FED --> D[16]FE --> F[5]FE --> E[9]</pre><pre class="mermaid">classDiagramclass HuffmanTable {    +Symbol : A    +Code : 0    +Symbol : B    +Code : 101    +Symbol : C    +Code : 100    +Symbol : D    +Code : 111    +Symbol : E    +Code : 1101    +Symbol : F    +Code : 1100}</pre><h4 id="h.264">H.264</h4><p>​然而，H.264显然更加复杂，因为它不是像JPEG那样压缩单一的静态图像。每30帧使用iFrame（JPEG），而其他29帧使用预测或双向预测,只对差异和运动进行编码，同时使用先前解码的帧作为参考。</p><h4 id="重构图片过程">重构图片过程</h4><ul><li><p>让我们回到JPEG，首先我们执行哈夫曼解码,根据哈夫曼表将编码变回DCT系数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compressed Data: 110100010...</span><br><span class="line">Decoded DCT Coefficients: [16, 11, -10, ...]</span><br></pre></td></tr></table></figure></li><li><p>并且分解游程编码（disassemble），然后把一连串的数字按照<strong>去交错</strong>（De-Zigzag）的方式重新排列为8x8矩阵。</p></li><li><p>接下来，我们执行<strong>反量化</strong>，通俗来讲就是讲各个值乘以量化表（之前讲过的那两张表，之前是除法），然后将所得常数乘以相应的基础图像（基础图像也是一开始就有的，之前也是除法），并将所有结果图像叠加在一起。</p></li><li><p>将蓝色跟红色色度图像放大，并将亮度和色度值重新转换为RGB色彩空间。</p></li></ul><blockquote><p>智能手机相机的拍摄照片至少有十几万像素，JPEG在几秒钟内就要完成压缩和解压缩，真是不可思议！</p></blockquote><h2 id="jpeg的缺点">JPEG的缺点</h2><p>有时候，你可以选择压缩的程度，而这会改变量化表的数值，这种四舍五入做除法的算法，如果压缩量变大，那么就会有更多的0，图像也会因此变得更小。</p><p>然而，如果压缩量过大，图像会出现artifacts，或者说块效应。它们看起开就像方块边缘的模糊斑点（类似于基础图像，就是离散余弦变换表中的特征，图像有很明显的横线或竖线）。</p><p>其次，压缩会去除高频数据，使得图像的精确度降低。</p><p>然而，这也是一种优点，因为没有一个相机能够做到完美对焦，所以很难分辨出未压缩和压缩的图像之间的区别。</p><p>但是，压缩矢量图的表现不佳，直线的压缩会出现锯齿。因为JPEG依靠基础图像来重建直线。</p><h2 id="总结">总结</h2><p>JPEG仍是使用量最多的图片压缩算法，因为它古老、为人熟知、无版权。</p><p>但还有很多其他图像格式，也具有很好的压缩能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dip-jpeg图像压缩&quot;&gt;DIP-JPEG图像压缩&lt;/h1&gt;
&lt;h2 id=&quot;为什么jpefg有用&quot;&gt;为什么JPEFG有用&lt;/h2&gt;
&lt;p&gt;人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。&lt;/p&gt;
&lt;p&gt;因此减少人类眼镜感知较弱的区域，即减少颜色的差异，</summary>
      
    
    
    
    <category term="DIP" scheme="https://abalone27.github.io/categories/DIP/"/>
    
    
    <category term="JPEG" scheme="https://abalone27.github.io/tags/JPEG/"/>
    
    <category term="数字图像处理" scheme="https://abalone27.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="算法" scheme="https://abalone27.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图像压缩" scheme="https://abalone27.github.io/tags/%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="哈夫曼编码" scheme="https://abalone27.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Three.Js简介</title>
    <link href="https://abalone27.github.io/2024/10/21/Three-Js%E7%AE%80%E4%BB%8B/"/>
    <id>https://abalone27.github.io/2024/10/21/Three-Js%E7%AE%80%E4%BB%8B/</id>
    <published>2024-10-21T08:33:28.000Z</published>
    <updated>2024-10-26T05:52:50.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="three.js-介绍">Three.Js 介绍</h1><p>Three.js由Ricardo Cabello在2010四月于GitHub首次发布。</p><figure><imgsrc="data:image/png;base64,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"alt="JavaScriptの3Dライブラリ”three.js”を使って遊 ..." /><figcaptionaria-hidden="true">JavaScriptの3Dライブラリ”three.js”を使って遊...</figcaption></figure><p>Three.js是一个跨浏览器的使用JavaScript函数库或API来在网页浏览器中创建和展示三维计算机图形的开源通用3D 代码库。Three.js使用WebGL渲染图形，也可通过插件使用WebGPU（实验性）、SVG 和 CSS3D 渲染器。源代码托管在GitHub。</p><h2 id="installation">Installation</h2><p>每个 three.js 项目至少需要一个 HTML 文件来定义网页，以及一个JavaScript 文件来运行你的 three.js代码。下面的结构和命名选择并非必需，但为了保持一致性，本指南将在全文中使用。</p><ul><li><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>My first three.js app<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><code>public/</code></p><ul><li><em>public/</em> 文件夹有时也被称为"静态（static）"文件夹，因为其中包含的文件会原封不动地推送到网站上。纹理（textures）、音频和3D 模型通常会放在这里。</li></ul><h2 id="creating-a-scene">Creating a Scene</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>()</span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">75</span>,<span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span>,<span class="number">0.1</span>,<span class="number">1000</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer =<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>()</span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">color</span>:<span class="number">0x00ff00</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br><span class="line"></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">z</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">    cube.<span class="property">rotation</span>.<span class="property">x</span> += <span class="number">0.01</span></span><br><span class="line">    cube.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.02</span></span><br><span class="line">    renderer.<span class="title function_">render</span>(scene,camera)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">animate</span>()</span><br></pre></td></tr></table></figure><ul><li>以上这行代码创建了一个不断旋转的正方体。</li><li><figure><img src="images/threejs.png" alt="threejs" /><figcaption aria-hidden="true">threejs</figcaption></figure></li></ul></li></ul><h2 id="解释代码">解释代码</h2><p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。</p><p>three.js 里有几种不同的相机，在这里，我们使用的是<strong>PerspectiveCamera</strong>（透视摄像机）。</p><p>第一个参数是<strong>视野角度（FOV）</strong>。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p><p>第二个参数是<strong>长宽比（aspect ratio）</strong>。也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p><p>接下来的两个参数是<strong>近截面</strong>（near）和<strong>远截面</strong>（far）。当物体某些部分比摄像机的<strong>远截面</strong>远或者比<strong>近截面</strong>近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p><p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer 渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL 时，可以使用这几种渲染器进行降级。</p><p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用<strong>setSize</strong> 传入一个较小的值，例如<strong>window.innerWidth/2</strong> 和<strong>window.innerHeight/2</strong>，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p><p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用<strong>setSize</strong> 时，将<strong>updateStyle</strong>（第三个参数）设为false。例如，假设你的canvas标签现在已经具有了 100% 的宽和高，调用<strong>setSize(window.innerWidth/2, window.innerHeight/2,false)</strong> 将使得你的应用程序以四分之一的大小来进行渲染。</p><p>最后一步很重要，我们将<strong>renderer</strong>（渲染器）的dom元素（renderer.domElement）添加到我们的HTML 文档中。这就是渲染器用来显示场景给我们看的canvas元素。</p><p>要创建一个立方体，我们需要一个<strong>BoxGeometry</strong>（立方体）对象.这个对象包含了一个立方体中所有的顶点（<strong>vertices</strong>）和面（<strong>faces</strong>）。未来我们将在这方面进行更多的探索。</p><p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是<strong>MeshBasicMaterial</strong>。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为<strong>0x00ff00</strong>，也就是绿色。这里所做的事情，和在 CSS 或者Photoshop 中使用十六进制（<strong>hexcolors</strong>）颜色格式来设置颜色的方式一致。</p><p>第三步，我们需要一个 <strong>Mesh</strong>（网格）。网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p><p>默认情况下，当我们调用 <strong>scene.add()</strong>的时候，物体将会被添加到 <strong>(0,0,0)</strong>坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p><h2 id="渲染场景">渲染场景</h2><p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“<strong>渲染循环</strong>”（renderloop）或者“<strong>动画循环</strong>”（animate loop）的东西。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function animate() &#123; requestAnimationFrame( animate ); renderer.render( scene, camera ); &#125; animate();</span><br></pre></td></tr></table></figure><p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说<em>“为什么我们不直接用setInterval 来实现刷新的功能呢？”</em>当然啦，我们的确可以用setInterval，但是，<strong>requestAnimationFrame</strong>有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p><h2 id="使立方体动起来">使立方体动起来</h2><p>在开始之前，如果你已经将上面的代码写入到了你所创建的文件中，你可以看到一个绿色的方块。让我们来做一些更加有趣的事—— 让它旋转起来。</p><p>将下列代码添加到 animate() 函数中 <strong>renderer.render</strong>调用的上方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cube.rotation.x += 0.01; cube.rotation.y += 0.01;</span><br></pre></td></tr></table></figure><p>这段代码每帧都会执行（正常情况下是60次/秒），这就让立方体有了一个看起来很不错的旋转动画。基本上来说，当应用程序运行时，如果你想要移动或者改变任何场景中的东西，都必须要经过这个动画循环。当然，你可以在这个动画循环里调用别的函数，这样你就不会写出有上百行代码的<strong>animate</strong> 函数。</p><h2 id="结果">结果</h2><p>祝贺你！你现在已经成功完成了你的第一个 three.js应用程序。虽然它很简单，但现在你已经有了一个入门的起点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;three.js-介绍&quot;&gt;Three.Js 介绍&lt;/h1&gt;
&lt;p&gt;Three.js由Ricardo Cabello在2010四月于GitHub首次发布。&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;data:image/png;base64,iVBORw0KGg</summary>
      
    
    
    
    <category term="前端" scheme="https://abalone27.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://abalone27.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript框架" scheme="https://abalone27.github.io/tags/javascript%E6%A1%86%E6%9E%B6/"/>
    
    <category term="WebGL" scheme="https://abalone27.github.io/tags/WebGL/"/>
    
    <category term="渲染引擎" scheme="https://abalone27.github.io/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>axios简介</title>
    <link href="https://abalone27.github.io/2024/10/21/axios%E7%AE%80%E4%BB%8B/"/>
    <id>https://abalone27.github.io/2024/10/21/axios%E7%AE%80%E4%BB%8B/</id>
    <published>2024-10-21T08:25:25.000Z</published>
    <updated>2024-10-26T05:52:31.478Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios">axios</h1><figure><img src="images/axios.png" alt="axios" /><figcaption aria-hidden="true">axios</figcaption></figure><p>axios对原生ajax进行了封装，简化书写，快速开发，用于发送<strong>异步</strong>请求。</p><p><a href="https://axios-http.com/zh/docs/intro">查看 axiosdocs</a></p><h2 id="定义">定义</h2><p>Axios 是一个基于 <em><ahref="https://javascript.info/promise-basics">promise</a></em>网络请求库，作用于<a href="https://nodejs.org/"><code>node.js</code></a>和浏览器中。 它是 <em><ahref="https://www.lullabot.com/articles/what-is-an-isomorphic-application">isomorphic</a></em>的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js<code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><h2 id="用例">用例</h2><p>发起一个 <code>GET</code> 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向给定ID的用户发起请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理成功情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述请求也可以按以下方式完成（可选）</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持async/await用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 由于<code>async/await</code> 是ECMAScript2017中的一部分，而且在IE和一些旧的浏览器中不支持，所以使用时务必要小心。</p></blockquote><p>发起一个 <code>POST</code> 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;axios&quot;&gt;axios&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;images/axios.png&quot; alt=&quot;axios&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;axios&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p</summary>
      
    
    
    
    <category term="前端" scheme="https://abalone27.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://abalone27.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="ajax" scheme="https://abalone27.github.io/tags/ajax/"/>
    
    <category term="异步" scheme="https://abalone27.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="javascript" scheme="https://abalone27.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学分支 CS Map</title>
    <link href="https://abalone27.github.io/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E6%94%AF/"/>
    <id>https://abalone27.github.io/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E6%94%AF/</id>
    <published>2024-10-20T16:02:46.371Z</published>
    <updated>2024-10-21T08:23:17.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="computer-science-map">Computer Science Map</h1><h2 id="计算机科学基础理论theroy">计算机科学基础理论（Theroy）</h2><h5 id="计算性理论-computability-theroy">1. 计算性理论 computabilitytheroy</h5><h5 id="算法-algorithm">2. 算法 algorithm</h5><h5 id="信息论-information-theroy">3. 信息论 information theroy</h5><h5 id="密码学-cryptography">4. 密码学 cryptography</h5><h5id="其他逻辑图论计算几何自动机理论量子计算并行编程形式化方法数据结构">5.其他（逻辑、图论、计算几何、自动机理论、量子计算、并行编程、形式化方法、数据结构）</h5><h2 id="计算机工程engineering">计算机工程（engineering）</h2><h5 id="处理机调度">1. 处理机调度</h5><h5 id="计算机体系结构-architecure">2. 计算机体系结构 architecure</h5><h5 id="软件与编程语言">3. 软件与编程语言</h5><h5 id="编译器-compilers">4. 编译器 compilers</h5><h5 id="操作系统-operating-systems">5. 操作系统 operating systems</h5><h5 id="软件工程-software-engineering">6. 软件工程 softwareengineering</h5><h5 id="网络-networking">7. 网络 networking</h5><h5 id="数据管理-data-management">8. 数据管理 data management</h5><h5 id="性能-performance">9. 性能 performance</h5><h5 id="图形学-graphics">10. 图形学 graphics</h5><h2 id="应用applications">应用（Applications）</h2><h5 id="优化-optimization">1. 优化 optimization</h5><h5 id="布尔可满足性问题-boolean-satisfiabilitysat">2. 布尔可满足性问题boolean satisfiability（SAT）</h5><h5 id="人工智能-artificial-intelligence">3. 人工智能 artificialintelligence</h5><h5 id="机器学习-machine-learning">4. 机器学习 machine learning</h5><ol type="1"><li>计算机视觉 computer vision</li></ol><ul><li>图像处理技术 image processing techniques</li></ul><ol start="2" type="1"><li>自然语言处理 natural language processing</li></ol><h5 id="大数据-big-data">5. 大数据 big data</h5><h5 id="物联网-internet-of-things">6. 物联网 Internet of things</h5><h5 id="hacking">7. hacking</h5><h5 id="计算科学-computational-science">8. 计算科学 computationalscience</h5><h5 id="超算-supter-computing">9. 超算 supter computing</h5><h5 id="人机交互-human-computer-interacting">10. 人机交互 human computerinteracting</h5><h5 id="机器人学-robitics">11。 机器人学 robitics</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;computer-science-map&quot;&gt;Computer Science Map&lt;/h1&gt;
&lt;h2 id=&quot;计算机科学基础理论theroy&quot;&gt;计算机科学基础理论（Theroy）&lt;/h2&gt;
&lt;h5 id=&quot;计算性理论-computability-theroy&quot;&gt;</summary>
      
    
    
    
    <category term="计算机科学" scheme="https://abalone27.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="计算机科学导航" scheme="https://abalone27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
</feed>
