<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Abalone27&#39;s Blog</title>
  
  
  <link href="https://abalone27.github.io/atom.xml" rel="self"/>
  
  <link href="https://abalone27.github.io/"/>
  <updated>2024-10-31T14:23:18.562Z</updated>
  <id>https://abalone27.github.io/</id>
  
  <author>
    <name>Yuxiang Bao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>🛜五层体系结构协议复习</title>
    <link href="https://abalone27.github.io/2024/10/27/%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/"/>
    <id>https://abalone27.github.io/2024/10/27/%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84%E5%8D%8F%E8%AE%AE%E5%A4%8D%E4%B9%A0/</id>
    <published>2024-10-27T12:00:00.000Z</published>
    <updated>2024-10-31T14:23:18.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五层体系结构协议复习">🛜五层体系结构协议复习</h1><p>首先我们需要了解为什么计算机网络要学习<strong>五层结构模型（TCP/IP模型）</strong>，因为这更简化，便于我们了解实际网络协议，并且更贴近现实的网络组成。</p><p>而七层模型（OSI）则是由<strong>国际标准化组织ISO</strong>制定的，为网络设计提供了框架，这其实是一个概念模型，虽然在实际上不常用，但为网络设计提供了参考。</p><h2 id="层">层</h2><p>让我们来看一下五层和七层有哪些层次，七层实际上在五层基础上加了两层：</p><ul><li>物理层 Physical</li><li>数据链路层 Data Link</li><li>网络层 Network</li><li>传输层 Transport<ul><li>会话层 Session</li><li>表示层 Presentation</li></ul></li><li>应用层 Application</li></ul><p>对于学过计网的人来说，夹在第四和第五之间的两个层或许不太熟悉，我们来介绍一下。<strong>会话层</strong>负责建立、管理和终止应用程序之间的会话。可见主要是Socket的建立和关闭操作。因为<strong>传输层</strong>只负责端到端的可靠传输，而给上层提供接口靠的是Session层；再看看<strong>表示层</strong>，它负责处理数据表示形式，包括加密、解密、压缩和格式化，确保不同系统之间的数据能正确解释，例如SSL/TLS加密、JPEG格式转换。可见表示层更切近应用层的具体应用。</p><p>让我们回归正题，复习一下五层结构的各类协议/技术。</p><h2 id="物理层">物理层</h2><p>实现设备之间的比特传输，定义物理连接（相邻的主机到主机）的标准。</p><ul><li>Ethernet（以太网）：有限网络的电气和信号标准。</li><li>IEEE 802.11（Wi-Fi）：定义无线局域网的通信方式。</li><li>光纤：高速骨干网传输。</li><li>Bluetooth（蓝牙）：短距离无线通信协议。</li></ul><h2 id="数据链路层">数据链路层</h2><p>实现同一局域网中的节点（主机和主机）间通信，负责帧的封装、差错检测和流量控制。</p><ul><li><p><strong>Ethernet（以太网）</strong>：最广泛的局域网数据传输协议，实现以太帧（Frame）格式的定义和介质访问控制。</p></li><li><p><strong>PPP（Point-to-PointProtocal）</strong>：提供点到点的链路传输，如电话拨号。<em>（也有特殊格式的帧）</em></p></li><li><p><strong>HDLC（High-Level Data LinkControl）</strong>：面向比特的链路控制协议，用来实现<strong>时钟同步</strong>。<em>（也有特殊格式的帧）</em></p></li><li><p><strong>ARP（Address ResolutionProtocol）</strong>：将IP地址解析为MAC地址，用于局域网通信，实现从三层到二层转换的方式。</p></li><li><p>VLAN（VirtualLAN）技术：虚拟局域网，使得相同交换机下的主机可以分配到不同子网。</p></li></ul><h2 id="网络层">网络层</h2><p>实现不同网络（局域网）之间的数据传输，负责路径选择和路由转发，实现Internet上主机到主机的连接。</p><ul><li><strong>IP（InternetProtocol）</strong>：网络层核心，定义数据包的封装与路由，它的任务只是根据<strong>数据包标头的ip地址，将数据包从源主机传送到目标主机</strong>。<ul><li>IPv4:广泛使用的协议，32位IP地址，使用ARP协议地址解析。</li><li>IPv6：128位地址，采用NDP协议。</li></ul></li><li><strong>ICMP（Internet Control MessageProtocol）</strong>：用于传递网络层错误消息和状态消息，广为流传的ping指令。它是依靠IP协议的协议，IP数据包中有它。利用TTL将路由诊断信息返回到源。</li><li>IGMP（Internel Group Management Protocol）：实现IP多播。</li></ul><figure><img src="/images/routing.png" alt="路由协议分类" /><figcaption aria-hidden="true">路由协议分类</figcaption></figure><h3 id="路由协议">路由协议</h3><h4 id="距离向量路由协议-dvrp">距离向量路由协议 DVRP</h4><p>距离向量路由协议（DVRP）也被称为“按<strong>跳数</strong>计算的路由算法”，其原理是：<strong>每个节点都维护到达目的节点所需的距离，每次更新将本节点到所有其他节点的距离向量发送给相邻节点，相邻节点再将其发给相邻节点……直到所有节点的距离向量被更新。最终每个节点都得到了到达目的节点的最短距离。</strong></p><p>常见的距离向量路由协议有</p><ul><li>RIP（Routing Information Protocol）</li><li>IGRP（Interior Gateway Routing Protocol）</li></ul><h4 id="链路状态路由协议-lsrp">链路状态路由协议 LSRP</h4><p>链路状态路由协议（LSRP）也被称为“基于<strong>状态</strong>的路由算法”，其原理是<strong>每个节点都把自己的链路状态信息发给相邻节点，相邻节点保存下来并传递给其它相邻节点。当所有节点都交换完成链路状态信息之后，每个节点通过计算最短路径算法得到网络的最短路径。</strong></p><p>常见的链路状态路由协议有</p><ul><li>OSPF（Open Shortest Path First）</li><li>IS-IS（Intermediate System to Intermediate System）</li></ul><h4 id="静态路由协议">静态路由协议</h4><p>在静态路由协议中，网络管理员<strong>手动配置路由表</strong>，然后<strong>路由器依据配置的路由表进行数据包的转发</strong>。</p><p>静态路由协议的<strong>缺点</strong>是不灵活，不能及时响应网络拓扑结构的变化。</p><h4 id="动态路由协议">动态路由协议</h4><p>动态路由协议可以根据网络拓扑结构的变化自动调整路由表，路由表的计算是通过运行路由协议来完成的。动态路由协议虽然比静态路由协议更复杂，但是具有灵活、自适应、可靠的优点。</p><p>常见的动态路由协议有</p><ul><li>BGP</li><li>OSPF</li><li>IS-IS</li><li>RIP</li><li>IGRP</li><li>EIGRP</li><li>OSPFv3</li></ul><h4 id="单播多播组播路由协议">单播、多播、组播路由协议</h4><p>单播路由协议是指进行单播转发的路由协议。多播路由协议是指进行多播转发的路由协议。组播路由协议是一种组播数据包传输的路由协议，与多播路由协议类似。</p><h4 id="内部网关协议和外部网关协议">内部网关协议和外部网关协议</h4><p>内部网关协议（IGP）是指在一个企业或组织内部部署、用于内部路由器之间通信的协议，如RIP、IGRP、EIGRP、OSPF和IS-IS等。外部网关协议（EGP）是指在不同的自治系统之间进行路由选择的协议，如BGP,各大ISP进行连接使用的是BSP协议（使用TCP连接）。</p><h4 id="工作原理">工作原理</h4><p>路由协议的工作原理可以分为四个步骤：</p><ul><li>邻居发现</li><li>路由表建立</li><li>路由表维护</li><li>路由表选择</li></ul><p>在选择适合特定网络环境的路由协议时，需要综合考虑网络规模、复杂性、性能需求和管理能力。通常，大型企业网络和互联网使用链路状态协议（如OSPF和IS-IS），而小型网络可能会选择距离向量协议（如RIP）。同时，BGP在连接自治系统之间的路由选择方面具有广泛的应用。</p><blockquote><p>以上路由协议部分内容均为<ahref="https://bbs.huaweicloud.com/blogs/399479">这篇华为云社区文章</a>的原创内容，本博客仅作为个人学习使用，无抄袭意图，了解详情请点击超链接进入此博客观看。</p></blockquote><h2 id="传输层">传输层</h2><p>提供端到端（port）的数据传输服务，确保数据包按顺序、无误地传输到目的主机。</p><ul><li><strong>TCP（Transmission ControlProtocol）</strong>：面向连接、可靠的协议，提供可靠的数据传输和流量控制。适用于需要保证数据完整性的应用，如HTTP、FTP。</li><li><strong>UDP（User DatagramProtocol）</strong>：无连接协议，不保证数据的可靠传输，但传输速度快。适用于实时应用，如视频流、在线游戏，DNS解析也用UDP。</li></ul><figure><img src="/images/transmission.jpg" alt="握手过程" /><figcaption aria-hidden="true">握手过程</figcaption></figure><ul><li>SCTP（Stream Control TransmissionProtocol）：同时支持多流传输的协议，适用于 VoIP 等应用。</li></ul><p>TCP与UDP的区别之一是<strong>重传丢失的数据</strong>。在TCP协议中，每个数据包都被赋予一个<strong>唯一的序列号</strong>。数据包发送者仔细跟踪发送了哪些数据包。作为响应，接收系统发出一个ACK数据包（代表“确认”），其中包含确认收到的数据包的序列号。如果序列号不匹配或丢失，发送机器将重新发送数据包。这个过程会持续下去，直到匹配的ACK确认传输成功。</p><p>第二大区别是通过<strong>三向握手建立持久化连接</strong>。在TCP中，三向握手是一种通信机制，以确保所有数据的发送和正确接收。简而言之，这发生在三个部分：</p><ul><li>初始化(SYN)：SYN是想要建立通信的设备发出的初始数据包。该数据包包含同步标志(SYN)和接收者的IP地址。</li><li><strong>确认启动(SYN-ACK)：</strong>接下来，接收者发回SYN-ACK数据包，假设它已准备好并愿意进行通信。</li><li><strong>最终确认(ACK)：</strong>一旦发送方收到SYN-ACK，就会发送最终ACK以确认有效连接。</li></ul><p>TCP面向连接是依赖于它的<strong>错误检测和流量控制</strong>等其他功能<em>（在后文）</em>，这些特性成为TCP面向连接的本质的支柱。</p><h4 id="tcp错误检测和流量控制简述">TCP错误检测和流量控制简述</h4><p>应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过MSS（TCP 最大报文段长度），就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在TCP 协议中，我们把每个分块称为一个 TCP 段（TCP Segment）（IP是超过MTU1500Bytes，即以太网帧的载荷后分片，⚠️注意分片标识、偏移量、MF更多分片标识、DF禁止分片标识这些概念）。TCP段对应标识有Seq序列号（如何组装在一起）、确认号（希望接受的下一个字节的序号，累积确认机制标识以及成功接受的数据，未确认的字节等待重传）、FIN关闭连接等。</p><p>在 TCP 报文段的头部中，有一个 <strong>16位窗口字段</strong>，用于表示接收方的缓冲区可用空间大小。<strong>窗口大小值</strong>告诉发送方当前允许发送的未确认数据量。通过该字段，发送方可以动态调整发送速度，确保不会导致接收方的缓冲区溢出。如果接收方缓冲区剩余空间减少，它会将窗口大小缩小；如果可用空间增大，它会增大窗口大小。</p><h2 id="应用层">应用层</h2><p>为应用程序提供网络服务接口，用户可以直接使用这些协议访问网络资源。</p><ul><li><p><strong>HTTP/HTTPS（Hypertext TransferProtocol）</strong>：用于传输网页数据，HTTPS 在 HTTP基础上添加了加密（TLS/SSL）。</p><figure><img src="/images/ssl1.png" alt="ssl1" /><figcaption aria-hidden="true">ssl1</figcaption></figure><figure><img src="/images/ssl2.png" alt="ssl2" /><figcaption aria-hidden="true">ssl2</figcaption></figure></li><li><p><strong>FTP（File TransferProtocol）</strong>：用于文件传输，支持上传和下载功能。</p></li><li><p><strong>SMTP（Simple Mail TransferProtocol）</strong>：用于电子邮件发送。</p></li><li><p><strong>POP3（Post Office Protocol 3）</strong> 和<strong>IMAP（Internet Message AccessProtocol）</strong>：用于电子邮件接收，IMAP 支持邮件同步。</p></li><li><p><strong>DNS（Domain Name System）</strong>：将域名解析为 IP地址。</p></li></ul><figure><img src="/images/ssh.png" alt="ssh" /><figcaption aria-hidden="true">ssh</figcaption></figure><ul><li><p><strong>Telnet</strong> 和<strong>SSH</strong>：用于远程登录，SSH 提供了加密的传输。</p></li><li><p><strong>DHCP（Dynamic Host ConfigurationProtocol）</strong>：用于自动分配 IP 地址。</p></li></ul><h4 id="urluniform-resource-identifier统一资源定位符">URL（uniformresource identifier，统一资源定位符）</h4><p>在HTTP协议中，用来标识唯一的资源。</p><p>Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的</p><h5 id="url组成">URL组成</h5><ol type="1"><li>访问资源的命名机制</li><li>存放资源的主机名</li><li>资源自身的名称，由路径表示，着重强调于资源。</li></ol><h4 id="http-request">HTTP Request</h4><figure><img src="/images/http1.webp" alt="http request" /><figcaption aria-hidden="true">http request</figcaption></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/562f25980001b1b106000338.jpg</span> <span class="meta">HTTP/1.1</span></span><br><span class="line">Host    img.mukewang.com</span><br><span class="line">User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36</span><br><span class="line">Accept    image/webp,image/*,*/*;q=0.8</span><br><span class="line">Referer    http://www.imooc.com/</span><br><span class="line">Accept-Encoding    gzip, deflate, sdch</span><br><span class="line">Accept-Language    zh-CN,zh;q=0.8</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP1.1</span><br><span class="line">Host:www.wrox.com</span><br><span class="line">User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:40</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive</span><br><span class="line"></span><br><span class="line">name=Professional%20Ajax&amp;publisher=Wiley</span><br></pre></td></tr></table></figure><h4 id="http-response">HTTP Response</h4><figure><img src="/images/http2.webp" alt="http response" /><figcaption aria-hidden="true">http response</figcaption></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET     请求指定的页面信息，并返回实体主体。</span><br><span class="line">HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</span><br><span class="line">POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</span><br><span class="line">PUT     从客户端向服务器传送的数据取代指定的文档的内容。</span><br><span class="line">DELETE      请求服务器删除指定的页面。</span><br><span class="line">CONNECT     HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</span><br><span class="line">OPTIONS     允许客户端查看服务器的性能。</span><br><span class="line">TRACE     回显服务器收到的请求，主要用于测试或诊断。</span><br></pre></td></tr></table></figure><p>关于HTTP协议，详情可参考<ahref="https://www.cnblogs.com/ranyonsue/p/5984001.html">这篇博客</a></p><h4 id="sslssh">SSL&amp;SSH</h4><p>SSH和SSL(都是网络安全协议，通过加密和认证提升两台设备间传输数据的安全性。但SSH和SSL的生效方式和服务目标存在差异。</p><p>SSH在两台设备间创建<strong>安全隧道</strong>，使这两台设备间可以安全地发送命令、传输数据等。例如，客户端通过SSH远程登录到一台服务器上，就可以安全地远程管理这台服务器，在服务器上执行想要的命令。</p><p>SSL则是使用<strong>SSL证书</strong>保证两台设备间安全地传输数据，而不是像SSH那样可以执行命令。例如，用户通过浏览器访问某安装了SSL证书且启用了HTTPS的服务器，浏览器和服务器之间可以安全地传输数据。</p><p>SSH就像一辆汽车，我们看不到这辆封闭的汽车里装载的是什么。而SSL就像一个封闭的集装箱，我们可以用不同的交通工具运输它，但看不到集装箱里装的是什么。</p>]]></content>
    
    
    <summary type="html">介绍了大部分五层体系结构协议，TCP/IP协议，帮助复习计算机网络知识。</summary>
    
    
    
    <category term="Network" scheme="https://abalone27.github.io/categories/Network/"/>
    
    
    <category term="复习" scheme="https://abalone27.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
    <category term="计算机网络" scheme="https://abalone27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="网络协议" scheme="https://abalone27.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>OS：处理机调度与死锁🔒</title>
    <link href="https://abalone27.github.io/2024/10/26/chapter%203%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/"/>
    <id>https://abalone27.github.io/2024/10/26/chapter%203%20%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/</id>
    <published>2024-10-26T05:43:00.000Z</published>
    <updated>2024-10-26T18:10:46.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理机调度与死锁">处理机调度与死锁🔒</h1><blockquote><p>Q:如果系统只有一个cpu,有两个进程要运行.进程A的运行时间将是1小时,进程B的运行时间是1分钟.那么认为操作系统让哪个进程先运行比较合理?</p></blockquote><p>A：与操作系统的调度策略有关，即更重视优先级还是到来顺序、时长等因素。</p><h2 id="调度">调度</h2><p>对处理机（CPU）资源进行分配。</p><h3 id="调度层次">调度层次</h3><p>高级（作业）调度、中级（内存）调度、低级（进程）调度。</p><p>区分主要是运行频率，<strong>低级调度最频繁</strong>，也是重点。</p><figure><img src="/images/diaodu1.png" alt="调度等级" /><figcaption aria-hidden="true">调度等级</figcaption></figure><p><strong>后备队列</strong>（Spooling Queue 或 BackupQueue）是指操作系统或系统调度过程中用于存放<strong>尚未进入内存执行的进程或任务</strong>的队列。根据实际情况，后备队列可以位于<strong>外存</strong>或与外存相关的区域，而非内存。</p><p>作业（Job）：一组需要完成的任务或程序的组合。</p><ul><li>高级调度：决定哪些后备队列中的（外存中的）作业调入内存并创建进程与分配资源。</li><li>中级调度：决定哪些进程<u>可参与竞争CPU</u>。（内存-&gt;外存）</li><li>低级调度：决定哪个进程可以<u>获得CPU。</u></li></ul><p>低级调度有两种方式：</p><ol type="1"><li>非抢占式：一直执行完成或自动阻塞。</li><li>抢占式：允许其他进程依据一定规则抢占CPU。</li></ol><p>（1）时间片原则、（2）优先权原则 、（3）短作业（进程）优先原则</p><figure><img src="/images/diaodu2.png" alt="调度设计" /><figcaption aria-hidden="true">调度设计</figcaption></figure><h2 id="周转时间-turnaround-time">1. 周转时间 (Turnaround Time)</h2><p>作业（进程）从提交（进入时刻）到完成的时间称为该作业的周转时间(T_i)：</p><p><span class="math display">\[T_i = \text{完成时刻} - \text{进入时刻}\]</span></p><h2 id="平均周转时间-average-turnaround-time">2. 平均周转时间 (AverageTurnaround Time)</h2><p>平均周转时间为 (n) 个作业（进程）周转时间的平均值：</p><p><span class="math display">\[T = \frac{1}{n} \left( \sum_{i=1}^{n} T_i \right)\]</span></p><h2 id="带权周转时间-weighted-turnaround-time">3. 带权周转时间 (WeightedTurnaround Time)</h2><p>作业（进程）周转时间 (T_i) 与实际运行时间 (T_{si})之比称为该作业的带权周转时间 (W_i)：</p><p><span class="math display">\[W_i = \frac{T_i}{T_{si}}\]</span></p><h2 id="平均带权周转时间-average-weighted-turnaround-time">4.平均带权周转时间 (Average Weighted Turnaround Time)</h2><p>平均带权周转时间为 (n) 个作业（进程）带权周转时间的平均值：</p><p><span class="math display">\[W = \frac{1}{n} \left( \sum_{i=1}^{n} \frac{T_i}{T_{si}} \right)\]</span></p><h2 id="调度算法">调度算法</h2><p>根据系统的资源分配策略所规定的资源分配方法</p><ol type="1"><li><h3 id="先来先服务fcfs">先来先服务（FCFS）</h3></li></ol><p>​ 作业调度：从后背队列选择一个或多个最先进入队列的作业</p><ol start="2" type="1"><li><h3 id="短作业进程优先sf">短作业（进程）优先（SF）</h3><p>从就绪队列中选择CPU执行时间最短的作业</p></li><li><h3 id="高响应比优先hrn">高响应比优先（HRN）</h3></li></ol><p>​ 选择待调度的作业中响应比最高的 <span class="math display">\[R_p = \frac{W_i + S_i}{S_i}\]</span> ​ Rp:响应比</p><p>​ Wi：已等待时间</p><p>​ Si：要求服务时间</p><ol start="4" type="1"><li><h3 id="最高优先权hpf">最高优先权（HPF）</h3></li></ol><p>​ 选择优先权最高的，其中又分为：</p><p>​ <strong>静态优先权</strong></p><p>​ <strong>动态优先权</strong></p><ol start="5" type="1"><li><h3 id="时间片轮转rr">时间片轮转（RR）</h3></li></ol><p>​ 每次为一个进程执行一个时间片T</p><ol start="6" type="1"><li><h3 id="多级队列调度">多级队列调度</h3></li></ol><p>​ 将就绪队列分为多种不同队列，不同队列使用不同调度算法</p><p>​ <img src="/images/diaodu0.png" alt="img" /></p><ol start="7" type="1"><li><h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3></li></ol><p>​设置多个就绪队列，从高到低赋予不同优先级，每个队列采用RR算法，时间片长度依次增加。</p><h2 id="死锁">死锁</h2><h3 id="概述">概述</h3><p><strong>死锁</strong>是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前进。</p><h3 id="产生原因">产生原因</h3><ol type="1"><li><strong>资源竞争</strong></li></ol><ul><li><p>当两个或以上进程需要两个或以上资源(非剥夺性资源or临时性资源)：</p><ol type="1"><li>可剥夺性资源</li><li>非剥夺性资源</li><li>临时性资源：由某进程产生，由另一进程使用的资源。（信号量）</li></ol></li></ul><ol start="2" type="1"><li><p><strong>进程推进非法</strong></p><p>请求和释放资源的顺序不当。</p></li></ol><h3 id="产生死锁必要条件">产生死锁必要条件</h3><ol type="1"><li><p>互斥条件：请求的资源为<strong>临界资源</strong></p><p><strong>临界资源（CriticalResource）</strong>：指<strong>多个进程或线程在同一时间只能由一个进程使用</strong>的资源。对这种资源的访问必须受到严格的控制，以防止数据<strong>不一致</strong>或<strong>竞争</strong>问题的发生。典型的临界资源包括<strong>共享内存、文件、数据库</strong>等。</p><blockquote><p>可见，访问临界资源必须要有<strong>同步或互斥机制（同步：信号量，互斥：锁）！！</strong></p></blockquote></li><li><p>请求和保持条件：申请新资源，保持旧资源</p></li><li><p>不剥夺条件：已获得的资源，在使用完之前，不被外力剥夺。</p></li><li><p>环路等待条件：互相等待资源</p></li></ol><h3 id="处理死锁的基本方法">处理死锁的基本方法</h3><ol type="1"><li>预防死锁：设置限制条件，破坏死锁产生</li><li>避免死锁：资源分配的动态方法</li><li>检测死锁：采取措施，解除死锁</li><li>解除死锁：剥夺资源或撤销进程回收♻️资源</li></ol><h2 id="银行家算法">银行家算法🏦</h2><h3 id="安全序列">安全序列</h3><p>安全状态，是指系统能按某种进程顺序(P1, P2, …，Pn)(称〈P1, P2, …,Pn〉序列为安全序列)，来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><p>​ • <strong>可用资源</strong>：目前系统中剩余的可用资源数量。</p><p>​ • <strong>最大需求</strong>：每个进程所需的最大资源量。</p><p>​ • <strong>已分配资源</strong>：每个进程当前占用的资源量。</p><p>需求 = <strong>最大需求</strong> - <strong>已分配资源</strong></p><p>要找到一个<strong>安全序列</strong>，需要按照银行家算法，依次寻找一个可以满足当前可用资源条件的进程，完成该进程后，释放其资源，增加可用资源。重复这个过程，直到所有进程都完成。</p><h3 id="算法实现">算法实现</h3><p>核心：根据系统是否处于安全状态，来决定分配资源与否。</p><p>对于银行家算法的具体实现主要由以下几个数据结构：</p><p>1、可利用资源向量Available：</p><p>一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目</p><p>2、最大需求矩阵Max：</p><p>一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求</p><p>3、分配矩阵Allocation：</p><p>一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数</p><p>4、需求矩阵Need：</p><p>一个n×m的矩阵，用以表示每一个进程还需的各类资源数</p><p>Need［i,j］=Max［i,j］-Allocation［i,j］</p><figure><img src="/images/bank.png" alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><p>设Requesti是进程Pi的请求向量，如果Requesti［j］=K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：</p><ol type="1"><li><p>如果Requesti［j］≤Need［i,j］，便转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</p></li><li><p>如果Requesti［j］≤Available［j］，便转向步骤(3)；否则，表示尚无足够资源，Pi须等待。</p></li><li><p>系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：</p></li></ol><p>① Available［j］∶=Available［j］-Requesti［j］;</p><p>② Allocation［i,j］∶=Allocation［i,j］+Requesti［j］;</p><p>③ Need［i,j］∶=Need［i,j］-Requesti［j］;</p><ol start="4" type="1"><li>系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。对于系统整体安全状态的检查，引入安全性算法，核心实现如下：</li></ol><blockquote><ol type="1"><li>设置两个向量：① 工作向量Work:它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work∶=Available;② Finish:它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish［i］∶=false;当有足够资源分配给进程时， 再令Finish［i］∶=true。</li><li>从进程集合中找到一个能满足下述条件的进程：  ① Finish［i］=false; ②Need［i,j］≤Work［j］； 若找到， 执行步骤(3)，否则，执行步骤(4)。<br /></li><li>当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：Work［j］∶=Work［i］+Allocation［i,j］; Finish［i］∶=true; go to step2;</li><li>如果所有进程的Finish［i］=true都满足，则表示系统处于安全状态；否则，系统处于不安全状态。</li></ol></blockquote><p>银行家算法的缺点如下：</p><p>1.很少有进程能够在运行前就知道其所需资源的最大值</p><p>2.而且进程数也不是固定的，往往在不断地变化（如新用户登录或退出）</p><p>3.原本可用的资源也可能突然间变成不可用（如磁带机可能坏掉）</p><p>4.银行家算法的开销较大，实时性不是很好</p><h2 id="解除死锁">解除死锁</h2><p>利用死锁定理</p><figure><img src="/images/diaodu3.png" alt="死锁解除" /><figcaption aria-hidden="true">死锁解除</figcaption></figure><p>对于死锁的解除，即<strong>（1）剥夺资源，(2) 撤消进程</strong>。</p><p>实用而又简便的方法是：<strong>逐个</strong>撤消那些<strong>代价最小</strong>的进程，或者，使<strong>撤消进程的数量最少</strong>，直至获得为解除死锁所需要的足够可用的资源。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;处理机调度与死锁&quot;&gt;处理机调度与死锁🔒&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Q:如果系统只有一个cpu,有两个进程要运行.进程A的运行时间将是1小时,进程B的运行时间是1分钟.那么认为操作系统让哪个进程先运行比较合理?&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="OS" scheme="https://abalone27.github.io/categories/OS/"/>
    
    
    <category term="操作系统" scheme="https://abalone27.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="死锁" scheme="https://abalone27.github.io/tags/%E6%AD%BB%E9%94%81/"/>
    
    <category term="复习" scheme="https://abalone27.github.io/tags/%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>最常见的图像压缩算法：JPEG</title>
    <link href="https://abalone27.github.io/2024/10/22/%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9AJPEG/"/>
    <id>https://abalone27.github.io/2024/10/22/%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%9AJPEG/</id>
    <published>2024-10-22T08:22:03.000Z</published>
    <updated>2024-10-26T18:09:55.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dip-jpeg图像压缩">DIP-JPEG图像压缩</h1><h2 id="为什么jpefg有用">为什么JPEFG有用</h2><p>人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。</p><p>因此减少人类眼镜感知较弱的区域，即减少颜色的差异，就可以实现压缩。</p><h2 id="压缩步骤">压缩步骤</h2><ol type="1"><li><p>首先需要进行色彩空间转换，每一个像素都有RGB的红绿蓝叠加，算法需要通过一个固定的公式算出<strong>Y（亮度）、Cb（蓝色色度）、Cr（红色色度）</strong>。</p></li><li><p>进行色度缩减取样，很多数据会被删除。将蓝色和红色色度分量层的像素按照2x2像素成一个区块这样划分。然后计算每个区块的平均值，然后缩小图像（4:2:0），使得含有1个平均值的由4个像素组成的区块只占一个像素的空间。于是那些我们👀眼睛不易感知的红蓝色度信息量shrinkto 1/4size，而亮度（luminance）保持不变。<em>（网上流行的包浆图就是这么来的）</em></p><blockquote><p>考虑一下刚才的两步，计算之前SIZE=1+1+1=3.0，计算之后为SIZE=1+1/4+1/4=1.5，图像已经变为原来大小的一半了。</p></blockquote></li><li><p>当我们查看图像时，会放大图像到原始尺寸，根据YCbCr重新计算RGB<em>（可能发生变化）</em></p></li><li><p>接下来的两个步骤是<strong>重点</strong>，进行<strong>离散余弦变换（DiscreteCosine Transform,DCT）</strong>和<strong>量化（Quantiaztion）</strong>。这利用了人眼不擅长感知高频率的图像信息的原理，即对于细节并不能精确感知。如阴影变化，和摄影中失焦的场景。以上两个步骤会遍历图像各个部分，并找到由高频率色度或亮度的像素频繁出现的区域，然后将这些人眼很难感知的像素删除。对于三个图层中的每一个图层进行以下步骤<em>（以亮度涂层举例）</em>：</p><ul><li>将整个图像<strong>按照8x8像素划分成许多区域</strong>，称为“区块”。每个区块因此有64像素，每个像素用0～255的数值表示。如果是亮度图层就是代表亮度值。</li><li>减去128来改变各个亮度数值，这样取值范围就变成了-128～-127。（亮度图-128为黑色，127为白色）</li><li>每一个区块内，我们可以先找到64个8x8基本图像（正弦函数的频率域图）并且每个图像都会有一个计算得出的DCT系数，原始图像可以通过计算出的每个基本图像✖️它对应的系数后再叠加64次得出。<em>（具体的数学公式笔者也不了解，请自行网上查阅）</em></li></ul><blockquote><p>DCT不能压缩或缩小图像，但下一个步骤，量化可以</p></blockquote></li><li><p>DCT后我们会有一个常数表，我们要把其中的各个值除上对应量化表中的各个值，并四舍五入取整。</p><figure><img src="/images/jpeg-0.png" alt="量化过程" /><figcaption aria-hidden="true">量化过程</figcaption></figure></li></ol><p>​ 量化表右下角数值偏高，是人眼不擅长感知德高频数据。而数值较小的左上角是人眼更容易区分的样式所在。</p><p>​ 在刚才的步骤中，我们舍弃了人眼无法感知的数据，针对色度，我们会采用一个数值更大的量化表，舍去更多的颜色数据。</p><h2 id="小结">小结</h2><ul><li>从本质上讲，整个余弦变换+量化的过程，<strong>一整张图像都使用了一组相同的64个基础图像和两个量化表：一个用于亮度，另一个用于色度。以便将8x8的像素区块转换为几个数字和一大堆的0。</strong></li></ul><h2 id="编码">编码</h2><h3 id="游程编码">游程编码</h3><ul><li><p>在这一步骤中，我们列出所有区块中的亮度与色度数值（更改后）。然而是这样的顺序：</p><figure><img src="/images/jpeg-1.png" alt="游程编码" /><figcaption aria-hidden="true">游程编码</figcaption></figure></li><li><p>因为这样子更可能找到一连串的非0数字。</p></li><li><p>接下来，在我们列出的数字中，使用游程编码Run length encodingalgorithm，列出我们有几个0。这样只有几十个数字的列表显然比0～255的方法压缩的多。</p></li></ul><p><img src="/images/jpeg-2.png" style="zoom:50%;" /></p><h3 id="哈夫曼编码-huffman-encoding">哈夫曼编码 Huffman Encoding</h3><p>​这种独立编码也运用在H.264视频压缩算法中（也被称为高级视频编码，AVC），是目前Youtube上传视频推荐的视频压缩算法。它使用了色度所见取样或色度抽样技术，以及离散余弦变换和量化技术的一些变种。</p><p>​ 这里对哈夫曼编码进行简述，感兴趣的可以查阅资料自行了解。</p><ol type="1"><li><p>需要对待编码的数据中每个符号出现的频率进行统计。这些频率将用于构建哈夫曼树。</p></li><li><p>哈夫曼树是一种二叉树，其中每个叶子节点代表一个符号，且路径长度与符号的频率相关。构建哈夫曼树的步骤如下：</p><p>​ 1.<strong>初始化</strong>：将所有符号视为独立的节点，并按照频率从小到大排序。</p><p>​ 2.<strong>合并最小频率的两个节点</strong>：将频率最小的两个节点合并为一个新的父节点，其频率为两个子节点频率之和。</p><p>​ 3.<strong>重复合并</strong>：将新节点加入节点列表中，重新排序，重复步骤2，直到所有节点合并成一棵树。</p></li><li><p>根据哈夫曼树<strong>生成哈夫曼表</strong>，从根节点到每个叶子节点的路径决定了该符号的哈夫曼编码。通常，向左分支记为0，向右分支记为1。</p></li></ol><pre class="mermaid">graph TDRoot[100]Root --> A[45]Root --> CBFED[55]CBFED --> CB[25]CBFED --> FED[30]CB --> C[12]CB --> B[13]FED --> FE[14]FED --> D[16]FE --> F[5]FE --> E[9]</pre><pre class="mermaid">classDiagramclass HuffmanTable {    +Symbol : A    +Code : 0    +Symbol : B    +Code : 101    +Symbol : C    +Code : 100    +Symbol : D    +Code : 111    +Symbol : E    +Code : 1101    +Symbol : F    +Code : 1100}</pre><h4 id="h.264">H.264</h4><p>​然而，H.264显然更加复杂，因为它不是像JPEG那样压缩单一的静态图像。每30帧使用iFrame（JPEG），而其他29帧使用预测或双向预测,只对差异和运动进行编码，同时使用先前解码的帧作为参考。</p><h4 id="重构图片过程">重构图片过程</h4><ul><li><p>让我们回到JPEG，首先我们执行哈夫曼解码,根据哈夫曼表将编码变回DCT系数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Compressed Data: 110100010...</span><br><span class="line">Decoded DCT Coefficients: [16, 11, -10, ...]</span><br></pre></td></tr></table></figure></li><li><p>并且分解游程编码（disassemble），然后把一连串的数字按照<strong>去交错</strong>（De-Zigzag）的方式重新排列为8x8矩阵。</p></li><li><p>接下来，我们执行<strong>反量化</strong>，通俗来讲就是讲各个值乘以量化表（之前讲过的那两张表，之前是除法），然后将所得常数乘以相应的基础图像（基础图像也是一开始就有的，之前也是除法），并将所有结果图像叠加在一起。</p></li><li><p>将蓝色跟红色色度图像放大，并将亮度和色度值重新转换为RGB色彩空间。</p></li></ul><blockquote><p>智能手机相机的拍摄照片至少有十几万像素，JPEG在几秒钟内就要完成压缩和解压缩，真是不可思议！</p></blockquote><h2 id="jpeg的缺点">JPEG的缺点</h2><p>有时候，你可以选择压缩的程度，而这会改变量化表的数值，这种四舍五入做除法的算法，如果压缩量变大，那么就会有更多的0，图像也会因此变得更小。</p><p>然而，如果压缩量过大，图像会出现artifacts，或者说块效应。它们看起开就像方块边缘的模糊斑点（类似于基础图像，就是离散余弦变换表中的特征，图像有很明显的横线或竖线）。</p><p>其次，压缩会去除高频数据，使得图像的精确度降低。</p><p>然而，这也是一种优点，因为没有一个相机能够做到完美对焦，所以很难分辨出未压缩和压缩的图像之间的区别。</p><p>但是，压缩矢量图的表现不佳，直线的压缩会出现锯齿。因为JPEG依靠基础图像来重建直线。</p><h2 id="总结">总结</h2><p>JPEG仍是使用量最多的图片压缩算法，因为它古老、为人熟知、无版权。</p><p>但还有很多其他图像格式，也具有很好的压缩能力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;dip-jpeg图像压缩&quot;&gt;DIP-JPEG图像压缩&lt;/h1&gt;
&lt;h2 id=&quot;为什么jpefg有用&quot;&gt;为什么JPEFG有用&lt;/h2&gt;
&lt;p&gt;人类眼镜的细胞对图像的感知程度，亮度比色度感知强烈的多。&lt;/p&gt;
&lt;p&gt;因此减少人类眼镜感知较弱的区域，即减少颜色的差异，</summary>
      
    
    
    
    <category term="DIP" scheme="https://abalone27.github.io/categories/DIP/"/>
    
    
    <category term="JPEG" scheme="https://abalone27.github.io/tags/JPEG/"/>
    
    <category term="数字图像处理" scheme="https://abalone27.github.io/tags/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
    <category term="算法" scheme="https://abalone27.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="图像压缩" scheme="https://abalone27.github.io/tags/%E5%9B%BE%E5%83%8F%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="哈夫曼编码" scheme="https://abalone27.github.io/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Three.Js简介</title>
    <link href="https://abalone27.github.io/2024/10/21/Three-Js%E7%AE%80%E4%BB%8B/"/>
    <id>https://abalone27.github.io/2024/10/21/Three-Js%E7%AE%80%E4%BB%8B/</id>
    <published>2024-10-21T08:33:28.000Z</published>
    <updated>2024-10-26T18:09:01.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="three.js-介绍">Three.Js 介绍</h1><p>Three.js由Ricardo Cabello在2010四月于GitHub首次发布。</p><figure><imgsrc="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATwAAACfCAMAAABTJJXAAAABelBMVEX///8AAAAhISH//e5ENxixsbGowd6MYkb4+PjC3u/8/Pzw8PD19fXh0LH7///o6Oje3t64uLjU1NTj4+OXl5cuPlz05Me+vr5tbW3Pz8+MjIxmZmZ1dXUcHBz79N4MAAAAFTPh7fwpTF5RUVE6OjqFhYWioqIqKiqlpaVCQkJZWVlLS0swMDCJiYkTExM+Pj59fX0AABAAAB0iAAAWCAD///fIvrextryYdloQQmf16t99cWqEkKBaQSFpi6nB3e8zFQAAQ3NAIgBAbY7bx7U9LiQ/U2VDVnlDFgA2AAATHC20q6BRQzYbMkWgrLiynYtPPzNSXmp2ZFQdISuNq8MnDQBPNBwjU30eAAC1xdIpRmGninOMcFZ+l7PKs5Y0LR4oNTs2JR+xmnlgU0FDTVj/7c9nSzJLWnLl3M94WjZuSStWMwAAADNSQyEEJD9SeJhcLRSXjH0yX3ybd2VELwAANFZeeIsACC5iPQAOLjwuHwWHbkPLtZqljny5o0J7AAAPwklEQVR4nO1d+YPbxBW2vHUxkoLP1OuLtPX69tobYAMsaaElhJYlCQstIeUOKV0KBOh9pP97572R5h7Flu3sSqvvh8TWSJb87Zt3zjznchkyZMiQIUOGDBkyZMiQ4RyidNYPkGB0nNlBwz3rp0goHERvlAlgDMycALP9pnfWD5M07DtOvhvwN58Uymf9PIlCg8hcrjzYCwUwv98860dKDjxCWA3+b+wOQwLbo9pZP1ZCMHacBn1VLNd7IX/jftM/2+dKBA4cp8Pf+ZWOwzVgZoIfA6L0FvKRan0cEthtZQIYhRrhSJOwUmM3zzRgPTPBVhBDWzEcJhqQmeC9zARbQJRe3zLkV3bnTAALmQ+tAz09G5qMPIJFpgFVgKdnE6pG4LgcMAvSLmQ+oIi5WekRVICvOgk7wASzKHjYyjQgQ9+m9Arg7ZWLQQySK1XazATvZj4gRQVFS8cIuRNjkJxfbU1D/qatZpYHRKVnkKOBExzvSzFIziu0WRCSmWDw9BrawTpoN6SGWI09ZbDZWrA8YL16oU0wsaUH6rEWuCZUrEqh0pNQKzAfcH6RTTBRemPlUB/iilCixibJJChWWyyNNa5fUBNc0pQe+HVjV3inSWYIn2VhwARfRA24UEQLCJlwU2pQegxNOnG5Ca4Wt/ig5xEd2dNry9yhZFpkKghBnDI3wcPdyoXyARui0nMnwJ00nrfFIBiC1PJUcJtcA+7Vq9t83nOFmiBaReBuVx63JV4gBOmWYXg/+KBCOyzFOZ2LIoBdpvRciCA6yjARsLnhKgxBSsghD1H85j7LA/YuhAB2QtkpgvOrmVZz4gVCkHwpGJYcZW80YWmY3UraLUgY3nqQOtnXx4cGTw/c6BmlNG8YbvaZABIfMM0Egj0l388DjV83jBs8vZbgRlt0Ym3ETHC+00ivBpyD7HhdC3cgmYqnhyFIKE8FrQIXotjcz3MBTKkGBIMJ4ueMjMNaeLsLDrErDlsFq+oI6FRSmEUgsjOEOVswD7tKDKK40S5Rb7bQNszks1rwpF5OWR6wRL+YMf4HdCSl11bd6F1rBQ64m7fB+6lxEzzrNNIkgC6axom1vE04mLI3Pc2NJjqxZ7yOhiBk5uZRPzb6XAMO0lNLD5MjlrhAiEHcse5Gl42OIA1BiLIMl2LhqaNJmEboHjTSkYYpcKU+bRmsIvP0/LHJjTZ5etSN7gJrC8kSec0+K8X1BikwwSA7A6aU5u2KIhNhDOLvGd1oovRa2kHI5HdLwSslXK6N2HK2bifxK8qHaDCFwHSvLqbmAk/Py5tdwYIh5QdudJ4aBsj6ade4jQMeBQ829kXOAkx2ajw1l+epORqDlMCdMX1P0ImK+OzDHyDUk6qfGKI8CG9mWy+TCBSEnF6x2ZoLAojHwJEp5S3c0WHpAGTyF8whWVhdyJzfAJrtif4kQJWdUoFZRSxOkHgMy2UWDjqK0sMQhL8lSq9tvTWEeuNkqz3dR/ab+ywu6AX63bKqRVV6wJ2YySdKr2u7sXpuErFrtAQlrgEB1vqimIymIUhb5AM8PYtTrFZMEgmTwaQQihND2wIVdygwa8jk9ywTHism9hmdFIA9tUacJaE8a96mwZVeEWa4msnf1+i0n5tAuPmIWdlwJIz7Wm64EIa3xanJdhKlt6fLrGsMV5II1WAKqASklSu7jEBlm0YY3hb3jE6bccGLbz43iShIzoUy4nTLCyqZ1TpbojcUFim7MxzGKojpbzDWlZ713ATClhoJS4y7LKgtVTrCCqnAiraBiBLwYczk72u6zRbqJRKB7GjA3EgJ5y6XTFdYpDzDbRpEPCfe3BqCNNT1pxHnJhFt4yRiJcaaao49YZHypNAI1vuYqyA535HrHCDn1pAtgSiY8sEY31PO5nrSzq22WGqJwsrHUBpLG3f4hVQPBOL7sMRoTNrBImXBCbT7bC1xELmzVkwSCT3+kkqMBfteIWGn5NSy1RlcxfA1rupL2VLStmr95DJZySCZDKIbPewbihM+9/QaKeQOfBKp8q+WGA1KT7gU7QZbYTYZqYmAcZiTQe5SULqQUXakbLlWYrTHIODODCfgepQHfKuz3O6mH3wa1prSU3dkEGeTIe4s6MvmKbDU448CR9BrdJgPOBnUQgKDpc3ocqdx64GQ0zOVGImnNzfFIIErWObDbrnOSnF7QXmWhresHJk6DFgQYSwxFs0xSD9wo/2hpMr8Bttp6vTABJOYuAHczdO52oyJlmW12a6pZoulHpybmrUmGpBlERzY8zd32IrI1MEP8sG2EqMpBgEPuUc9mJG6jB5QEjQgYJxS7kLZqdlKjGCOfe0KVoKo6sMIogGZAI7TtD5KBspORNzZVZWeXIKY2/03t4FBnCVjmAoQ2Zlj7GQpMSpazVVKPZOoBN2Bk4IyWRTcIEKwBRJyttlVyzcj2zq9nCqjqQT1zqxxpxSDFDVXsOoYFvQgUlJijAbGqBP75m2BWQ82vPStwxJ808ai1CFIjlg3b/MYxAM3Wg11J2Yrbd5YlD5wh2xm6p8yCsNbsxs9MCo9f6bLaCpBZKcttDBT+6eEhYySuXwD4a2W8sMyWUpKjNFA2SnK/VMEOop0XUEZuDOUenyDp1dKU4kxGmBP0RnzCmx1QF7on4KeXs3qRrc1eSxZeE4jinPBYDZbbNXwsF5FTiEGiSjf1NXwNnVlskgoQYS0eZtowFpQnrW40VXIisrv7Ssi0wdNdqCDFBPA6X430o32u1KKvRoVrqQQZJ519ayRV2CZYYC9fNMTBTdWifHai8+seMX5gZ+3cOOKS5Trtv4pAyEKi1VifMlxXn4C7B29Mrm+hdtEpUY8vkLZ0j9F2K9SiZZRM3Z+RC56esWLVsfhL8htfrn5zx1ERPAFR8LCsHnbCZVevBIjkvfqqletjKPXyG1+tfnPrTrabp4QWJ4lWq1fmQj9U2QNOQ08vZglxickeTu/Jrd5fQsfbJ1sUJ7NezRp5zf7rIdeL/ABEQNqrfHcZbkTlM8TIi934w3n5s+28LlTy6JDyp2Q0yvxzdtD1j+FKj0sgy9Z6tl5/03O3pMiL+dup5hiTo3gSr0ZMCSZ0AbfO7vA7gGwSa+KZfAln+7oN87lMyBvSzDng3GHGPKhxq9lqX8KGOSFs3yZjHCXJvJck9KD2teU8qHHILBNLUxjzemL6bLc/ZacfJm/F8nzPIvhciWF4HkW/eB5K0xN3/M3Up1q62kQyLCEc7msxK8BSiNhhe2yJUbkznnrgKCDTmtI3uHx2zBy67ZgTO5cQR1//A73Zg6Pv8D7PbiteLw+nuU4J5Z45fDd967zN/Rm5Oz120booiWt1LPGILA8hZrgZUs9p8+LbuPvcszPu/H78OBDNocvoXdx9D4evouHjj9gFz93W/zgO/xTH94z3ZkEMs6Pg9ePrggP8Yc14w7WyiOEUvqKikGwyYi+6MKMZ8WnFsh7+kPh6HOhRwHk3TwK6ELyPpQuFwKGj6SBjw23foqT94l0MqM0JmCLhCi+6irHiBgES7lLlxh3Xgse+AX4B+ckkofz/+qk/SkOvhycDeR99jm94AGcex9f3hwUBl/I7L2Eb08Ghfrb7K+igJN3FHziQWeCj7FueCMVwfSyIZhjc17A3DgkEn90dIMBlOBkO/pSkIVLgSReD3zvn8C7y1Qu6YmvCif+iQ6c4izXzTcnD/8Egcr0r9WNk3wViLvakQ+59AXm2KhY4+zEAwpUV4XPtEPiyDjf0deUvL+wuOAr8crDP/N3XwN34cDO944pEOPkfWkWzdiAXe2BaBVN/QgtMYhv6V0YCSN5/MuAQrpFh5G8u8+IFzo8wjp6PhQ9OO8bPnB6RdCbDIy8w2+ls9dHkSk9a3nWYBNK1v57UTCR97E8/JB+NyDlIT/zEy6TiPuh1ruv2IiPTKIlkbeukZARipalbGhsMoPcrb4Tz0SeoKLAIP+Uk/dzfuZTypdGYwzD3yta/xF5/w/1tvxqePXc7Q0u9Q2UnrVs6Oienr0cGY245KHEXC9wHDvUSdsBF/G2MPADaEr1tpy8R6hKrz4YNDeUWaaiZS8bTjRO8dw4ZbK45O186+j4O4l8nn3BMKDlPQW5/Ss76+TFjXSGBXsawYcWg2CpJ1aZLDZ5fzOR94zmeVPcVW8rTnohHLm6CbtLlN7B3M4HlGfFMDo+d+tJXl7GLXDSUPLk491bmqMnacyjMLZ1DNpxddTpJ1nLs46k9NbZibcWeSYrieQ9NkxQzY13/Eow3deXPfpTDfYlJpLSi1UmC7GWtTXWv75fhgGVPED1hw+Cqb8efPpXmNmaQ4sxSGEd7uKTB+7cN6Yv+tIyDJjIo1mef67vMfMFAmPTz4wSyRwGOb2gMWhcxCYPIwyT6F1aZvKZycv9yxSNrIwWETveBE5rDs0TL2Hzi7gADv4dhzyMbcVQ4ijcIv21wl65EXggp/VWGPdz8twyT0TDw2xA8pqwJ95rHrD6otIcOoxBwLLM1nHPUYDwa+A3XIE8vNK5eY/uqbz2LovjbuDASRMGXBygGU48HrDHw7OvwL/Db+Bf+488DeICRAvmolsT64u8OXTQQ5X/PFpcYN7EebDfnnV5MpQPR5AX5POcq3uLxYw6d4GRpfk857298YLW9uhU/C+8DGINRh4mFJyrs/F0/OmGrC2KFrOnjT5rArcINCCNQYTGIbFxn2lXyJ5o5Dl28kTvFsFS6B8qA6/jgJE8zGUJeHO9b0OhtOctCz8Q0gHlQl7UoBy5bJnMikOWM4esG6zAEVU2CGaQSoFp+p187ek7wtcWi0U33hAGPgvKG48EweI67/COeO713CbQ1H67xmtyAeyNyEuYEtMNRIPX2p+TiXNCv/vpZCIlc08nJ+H748mJpsxPW5g8v/rg4J4klG6z34OBt076POA/brfDMpFobd3THyaf47nXN7QH3dyeV6ovOhFbzVa+3TrXurb6rv1TdVcl4uTVsWeJMIpCc+jk7iaz+HmbQlR73mCFhamTZUKwZfLE/kU6DE1VE4Utk2etkeWCMlmid+J9uV3yrO15Y5bJzhVOody+zdW7LZvSs/7EVzLwv3EHc3cbCGLtgPDWZL7jlRjPDS6FrsJ3jz83Piw9yWsJ34kXknd5m4KH4a2u9OKWGM8P7vSuOM6DbWxhEaG3571wO/HiA9LFrnboQu3Eiw9QenKeM43NPreFmaLd0tmwcktoyUpvrRLjhYMc3qa12eeWUBSVHjb7SWXDyi1B+Mkt9hPeGZZEi+Wd1i4xXjwQpTfEF8LPn2dYEmF4K/2Ed4YlMcVYDJou9jLuVkUfPD1sSJvmhpVbAvQkb2+yxHiRUEp6ifFMgSXa1Des3BIOMu7io3oxGlZuCeUsFZAhQ4YMGTJkyJAh5fg/cdxPZwRJ5TQAAAAASUVORK5CYII="alt="JavaScriptの3Dライブラリ”three.js”を使って遊 ..." /><figcaptionaria-hidden="true">JavaScriptの3Dライブラリ”three.js”を使って遊...</figcaption></figure><p>Three.js是一个跨浏览器的使用JavaScript函数库或API来在网页浏览器中创建和展示三维计算机图形的开源通用3D 代码库。Three.js使用WebGL渲染图形，也可通过插件使用WebGPU（实验性）、SVG 和 CSS3D 渲染器。源代码托管在GitHub。</p><h2 id="installation">Installation</h2><p>每个 three.js 项目至少需要一个 HTML 文件来定义网页，以及一个JavaScript 文件来运行你的 three.js代码。下面的结构和命名选择并非必需，但为了保持一致性，本指南将在全文中使用。</p><ul><li><p><code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>My first three.js app<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><code>public/</code></p><ul><li><em>public/</em> 文件夹有时也被称为"静态（static）"文件夹，因为其中包含的文件会原封不动地推送到网站上。纹理（textures）、音频和3D 模型通常会放在这里。</li></ul><h2 id="creating-a-scene">Creating a Scene</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&quot;three&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>()</span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">75</span>,<span class="variable language_">window</span>.<span class="property">innerWidth</span>/<span class="variable language_">window</span>.<span class="property">innerHeight</span>,<span class="number">0.1</span>,<span class="number">1000</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> renderer =<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGLRenderer</span>()</span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>,<span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123;<span class="attr">color</span>:<span class="number">0x00ff00</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry,material)</span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br><span class="line"></span><br><span class="line">camera.<span class="property">position</span>.<span class="property">z</span>=<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(animate)</span><br><span class="line">    cube.<span class="property">rotation</span>.<span class="property">x</span> += <span class="number">0.01</span></span><br><span class="line">    cube.<span class="property">rotation</span>.<span class="property">y</span> += <span class="number">0.02</span></span><br><span class="line">    renderer.<span class="title function_">render</span>(scene,camera)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">animate</span>()</span><br></pre></td></tr></table></figure><ul><li>以上这行代码创建了一个不断旋转的正方体。</li><li><figure><img src="/images/threejs.png" alt="效果图" /><figcaption aria-hidden="true">效果图</figcaption></figure></li></ul></li></ul><h2 id="解释代码">解释代码</h2><p>我们花一点点时间来解释一下这里发生了什么。我们现在建立了场景、相机和渲染器。</p><p>three.js 里有几种不同的相机，在这里，我们使用的是<strong>PerspectiveCamera</strong>（透视摄像机）。</p><p>第一个参数是<strong>视野角度（FOV）</strong>。视野角度就是无论在什么时候，你所能在显示器上看到的场景的范围，它的单位是角度(与弧度区分开)。</p><p>第二个参数是<strong>长宽比（aspect ratio）</strong>。也就是你用一个物体的宽除以它的高的值。比如说，当你在一个宽屏电视上播放老电影时，可以看到图像仿佛是被压扁的。</p><p>接下来的两个参数是<strong>近截面</strong>（near）和<strong>远截面</strong>（far）。当物体某些部分比摄像机的<strong>远截面</strong>远或者比<strong>近截面</strong>近的时候，该这些部分将不会被渲染到场景中。或许现在你不用担心这个值的影响，但未来为了获得更好的渲染性能，你将可以在你的应用程序里去设置它。</p><p>接下来是渲染器。这里是施展魔法的地方。除了我们在这里用到的WebGLRenderer 渲染器之外，Three.js同时提供了其他几种渲染器，当用户所使用的浏览器过于老旧，或者由于其他原因不支持WebGL 时，可以使用这几种渲染器进行降级。</p><p>除了创建一个渲染器的实例之外，我们还需要在我们的应用程序里设置一个渲染器的尺寸。比如说，我们可以使用所需要的渲染区域的宽高，来让渲染器渲染出的场景填充满我们的应用程序。因此，我们可以将渲染器宽高设置为浏览器窗口宽高。对于性能比较敏感的应用程序来说，你可以使用<strong>setSize</strong> 传入一个较小的值，例如<strong>window.innerWidth/2</strong> 和<strong>window.innerHeight/2</strong>，这将使得应用程序在渲染时，以一半的长宽尺寸渲染场景。</p><p>如果你希望保持你的应用程序的尺寸，但是以较低的分辨率来渲染，你可以在调用<strong>setSize</strong> 时，将<strong>updateStyle</strong>（第三个参数）设为false。例如，假设你的canvas标签现在已经具有了 100% 的宽和高，调用<strong>setSize(window.innerWidth/2, window.innerHeight/2,false)</strong> 将使得你的应用程序以四分之一的大小来进行渲染。</p><p>最后一步很重要，我们将<strong>renderer</strong>（渲染器）的dom元素（renderer.domElement）添加到我们的HTML 文档中。这就是渲染器用来显示场景给我们看的canvas元素。</p><p>要创建一个立方体，我们需要一个<strong>BoxGeometry</strong>（立方体）对象.这个对象包含了一个立方体中所有的顶点（<strong>vertices</strong>）和面（<strong>faces</strong>）。未来我们将在这方面进行更多的探索。</p><p>接下来，对于这个立方体，我们需要给它一个材质，来让它有颜色。Three.js自带了几种材质，在这里我们使用的是<strong>MeshBasicMaterial</strong>。所有的材质都存有应用于他们的属性的对象。在这里为了简单起见，我们只设置一个color属性，值为<strong>0x00ff00</strong>，也就是绿色。这里所做的事情，和在 CSS 或者Photoshop 中使用十六进制（<strong>hexcolors</strong>）颜色格式来设置颜色的方式一致。</p><p>第三步，我们需要一个 <strong>Mesh</strong>（网格）。网格包含一个几何体以及作用在此几何体上的材质，我们可以直接将网格对象放入到我们的场景中，并让它在场景中自由移动。</p><p>默认情况下，当我们调用 <strong>scene.add()</strong>的时候，物体将会被添加到 <strong>(0,0,0)</strong>坐标。但将使得摄像机和立方体彼此在一起。为了防止这种情况的发生，我们只需要将摄像机稍微向外移动一些即可。</p><h2 id="渲染场景">渲染场景</h2><p>现在，如果将之前写好的代码复制到HTML文件中，你不会在页面中看到任何东西。这是因为我们还没有对它进行真正的渲染。为此，我们需要使用一个被叫做“<strong>渲染循环</strong>”（renderloop）或者“<strong>动画循环</strong>”（animate loop）的东西。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">animate</span>() &#123; <span class="built_in">requestAnimationFrame</span>( animate ); renderer<span class="selector-class">.render</span>( scene, camera ); &#125; <span class="built_in">animate</span>();</span><br></pre></td></tr></table></figure><p>在这里我们创建了一个使渲染器能够在每次屏幕刷新时对场景进行绘制的循环（在大多数屏幕上，刷新率一般是60次/秒）。如果你是一个浏览器游戏开发的新手，你或许会说<em>“为什么我们不直接用setInterval 来实现刷新的功能呢？”</em>当然啦，我们的确可以用setInterval，但是，<strong>requestAnimationFrame</strong>有很多的优点。最重要的一点或许就是当用户切换到其它的标签页时，它会暂停，因此不会浪费用户宝贵的处理器资源，也不会损耗电池的使用寿命。</p><h2 id="使立方体动起来">使立方体动起来</h2><p>在开始之前，如果你已经将上面的代码写入到了你所创建的文件中，你可以看到一个绿色的方块。让我们来做一些更加有趣的事—— 让它旋转起来。</p><p>将下列代码添加到 animate() 函数中 <strong>renderer.render</strong>调用的上方：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">cube</span>.rotation.x += <span class="number">0</span>.<span class="number">01</span>; cube.rotation.y += <span class="number">0</span>.<span class="number">01</span>;</span><br></pre></td></tr></table></figure><p>这段代码每帧都会执行（正常情况下是60次/秒），这就让立方体有了一个看起来很不错的旋转动画。基本上来说，当应用程序运行时，如果你想要移动或者改变任何场景中的东西，都必须要经过这个动画循环。当然，你可以在这个动画循环里调用别的函数，这样你就不会写出有上百行代码的<strong>animate</strong> 函数。</p><h2 id="结果">结果</h2><p>祝贺你！你现在已经成功完成了你的第一个 three.js应用程序。虽然它很简单，但现在你已经有了一个入门的起点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;three.js-介绍&quot;&gt;Three.Js 介绍&lt;/h1&gt;
&lt;p&gt;Three.js由Ricardo Cabello在2010四月于GitHub首次发布。&lt;/p&gt;
&lt;figure&gt;
&lt;img
src=&quot;data:image/png;base64,iVBORw0KGg</summary>
      
    
    
    
    <category term="前端" scheme="https://abalone27.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://abalone27.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="javascript框架" scheme="https://abalone27.github.io/tags/javascript%E6%A1%86%E6%9E%B6/"/>
    
    <category term="WebGL" scheme="https://abalone27.github.io/tags/WebGL/"/>
    
    <category term="渲染引擎" scheme="https://abalone27.github.io/tags/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>axios简介</title>
    <link href="https://abalone27.github.io/2024/10/21/axios%E7%AE%80%E4%BB%8B/"/>
    <id>https://abalone27.github.io/2024/10/21/axios%E7%AE%80%E4%BB%8B/</id>
    <published>2024-10-21T08:25:25.000Z</published>
    <updated>2024-10-26T06:03:25.925Z</updated>
    
    <content type="html"><![CDATA[<h1 id="axios">axios</h1><figure><img src="/images/axios.png" alt="axios" /><figcaption aria-hidden="true">axios</figcaption></figure><p>axios对原生ajax进行了封装，简化书写，快速开发，用于发送<strong>异步</strong>请求。</p><p><a href="https://axios-http.com/zh/docs/intro">查看 axiosdocs</a></p><h2 id="定义">定义</h2><p>Axios 是一个基于 <em><ahref="https://javascript.info/promise-basics">promise</a></em>网络请求库，作用于<a href="https://nodejs.org/"><code>node.js</code></a>和浏览器中。 它是 <em><ahref="https://www.lullabot.com/articles/what-is-an-isomorphic-application">isomorphic</a></em>的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js<code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。</p><h2 id="用例">用例</h2><p>发起一个 <code>GET</code> 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向给定ID的用户发起请求</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理成功情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理错误情况</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述请求也可以按以下方式完成（可选）</span></span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">ID</span>: <span class="number">12345</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 总是会执行</span></span><br><span class="line">  &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持async/await用法</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/user?ID=12345&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong> 由于<code>async/await</code> 是ECMAScript2017中的一部分，而且在IE和一些旧的浏览器中不支持，所以使用时务必要小心。</p></blockquote><p>发起一个 <code>POST</code> 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;Fred&#x27;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;Flintstone&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;axios&quot;&gt;axios&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;/images/axios.png&quot; alt=&quot;axios&quot; /&gt;
&lt;figcaption aria-hidden=&quot;true&quot;&gt;axios&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://abalone27.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://abalone27.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="ajax" scheme="https://abalone27.github.io/tags/ajax/"/>
    
    <category term="异步" scheme="https://abalone27.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="javascript" scheme="https://abalone27.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学分支 CS Map</title>
    <link href="https://abalone27.github.io/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E6%94%AF/"/>
    <id>https://abalone27.github.io/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E6%94%AF/</id>
    <published>2024-10-20T16:02:46.371Z</published>
    <updated>2024-10-21T08:23:17.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="computer-science-map">Computer Science Map</h1><h2 id="计算机科学基础理论theroy">计算机科学基础理论（Theroy）</h2><h5 id="计算性理论-computability-theroy">1. 计算性理论 computabilitytheroy</h5><h5 id="算法-algorithm">2. 算法 algorithm</h5><h5 id="信息论-information-theroy">3. 信息论 information theroy</h5><h5 id="密码学-cryptography">4. 密码学 cryptography</h5><h5id="其他逻辑图论计算几何自动机理论量子计算并行编程形式化方法数据结构">5.其他（逻辑、图论、计算几何、自动机理论、量子计算、并行编程、形式化方法、数据结构）</h5><h2 id="计算机工程engineering">计算机工程（engineering）</h2><h5 id="处理机调度">1. 处理机调度</h5><h5 id="计算机体系结构-architecure">2. 计算机体系结构 architecure</h5><h5 id="软件与编程语言">3. 软件与编程语言</h5><h5 id="编译器-compilers">4. 编译器 compilers</h5><h5 id="操作系统-operating-systems">5. 操作系统 operating systems</h5><h5 id="软件工程-software-engineering">6. 软件工程 softwareengineering</h5><h5 id="网络-networking">7. 网络 networking</h5><h5 id="数据管理-data-management">8. 数据管理 data management</h5><h5 id="性能-performance">9. 性能 performance</h5><h5 id="图形学-graphics">10. 图形学 graphics</h5><h2 id="应用applications">应用（Applications）</h2><h5 id="优化-optimization">1. 优化 optimization</h5><h5 id="布尔可满足性问题-boolean-satisfiabilitysat">2. 布尔可满足性问题boolean satisfiability（SAT）</h5><h5 id="人工智能-artificial-intelligence">3. 人工智能 artificialintelligence</h5><h5 id="机器学习-machine-learning">4. 机器学习 machine learning</h5><ol type="1"><li>计算机视觉 computer vision</li></ol><ul><li>图像处理技术 image processing techniques</li></ul><ol start="2" type="1"><li>自然语言处理 natural language processing</li></ol><h5 id="大数据-big-data">5. 大数据 big data</h5><h5 id="物联网-internet-of-things">6. 物联网 Internet of things</h5><h5 id="hacking">7. hacking</h5><h5 id="计算科学-computational-science">8. 计算科学 computationalscience</h5><h5 id="超算-supter-computing">9. 超算 supter computing</h5><h5 id="人机交互-human-computer-interacting">10. 人机交互 human computerinteracting</h5><h5 id="机器人学-robitics">11。 机器人学 robitics</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;computer-science-map&quot;&gt;Computer Science Map&lt;/h1&gt;
&lt;h2 id=&quot;计算机科学基础理论theroy&quot;&gt;计算机科学基础理论（Theroy）&lt;/h2&gt;
&lt;h5 id=&quot;计算性理论-computability-theroy&quot;&gt;</summary>
      
    
    
    
    <category term="计算机科学" scheme="https://abalone27.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
    <category term="计算机科学导航" scheme="https://abalone27.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
</feed>
